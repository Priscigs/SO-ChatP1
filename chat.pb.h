// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chat.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_chat_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_chat_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chat_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_chat_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_chat_2eproto;
namespace chat_sistOS {
class Answer;
struct AnswerDefaultTypeInternal;
extern AnswerDefaultTypeInternal _Answer_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class NewUser;
struct NewUserDefaultTypeInternal;
extern NewUserDefaultTypeInternal _NewUser_default_instance_;
class Status;
struct StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserList;
struct UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserOption;
struct UserOptionDefaultTypeInternal;
extern UserOptionDefaultTypeInternal _UserOption_default_instance_;
class UsersOnline;
struct UsersOnlineDefaultTypeInternal;
extern UsersOnlineDefaultTypeInternal _UsersOnline_default_instance_;
}  // namespace chat_sistOS
PROTOBUF_NAMESPACE_OPEN
template<> ::chat_sistOS::Answer* Arena::CreateMaybeMessage<::chat_sistOS::Answer>(Arena*);
template<> ::chat_sistOS::Message* Arena::CreateMaybeMessage<::chat_sistOS::Message>(Arena*);
template<> ::chat_sistOS::NewUser* Arena::CreateMaybeMessage<::chat_sistOS::NewUser>(Arena*);
template<> ::chat_sistOS::Status* Arena::CreateMaybeMessage<::chat_sistOS::Status>(Arena*);
template<> ::chat_sistOS::User* Arena::CreateMaybeMessage<::chat_sistOS::User>(Arena*);
template<> ::chat_sistOS::UserList* Arena::CreateMaybeMessage<::chat_sistOS::UserList>(Arena*);
template<> ::chat_sistOS::UserOption* Arena::CreateMaybeMessage<::chat_sistOS::UserOption>(Arena*);
template<> ::chat_sistOS::UsersOnline* Arena::CreateMaybeMessage<::chat_sistOS::UsersOnline>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace chat_sistOS {

// ===================================================================

class UserList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.UserList) */ {
 public:
  inline UserList() : UserList(nullptr) {}
  ~UserList() override;
  explicit PROTOBUF_CONSTEXPR UserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserList(const UserList& from);
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserList& operator=(UserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }
  inline void Swap(UserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserList& from) {
    UserList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.UserList";
  }
  protected:
  explicit UserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kListFieldNumber = 1,
  };
  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bool list = 1;
  void clear_list();
  bool list() const;
  void set_list(bool value);
  private:
  bool _internal_list() const;
  void _internal_set_list(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.UserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    bool list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class UsersOnline final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.UsersOnline) */ {
 public:
  inline UsersOnline() : UsersOnline(nullptr) {}
  ~UsersOnline() override;
  explicit PROTOBUF_CONSTEXPR UsersOnline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UsersOnline(const UsersOnline& from);
  UsersOnline(UsersOnline&& from) noexcept
    : UsersOnline() {
    *this = ::std::move(from);
  }

  inline UsersOnline& operator=(const UsersOnline& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersOnline& operator=(UsersOnline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UsersOnline& default_instance() {
    return *internal_default_instance();
  }
  static inline const UsersOnline* internal_default_instance() {
    return reinterpret_cast<const UsersOnline*>(
               &_UsersOnline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(UsersOnline& a, UsersOnline& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersOnline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UsersOnline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UsersOnline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UsersOnline>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UsersOnline& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UsersOnline& from) {
    UsersOnline::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersOnline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.UsersOnline";
  }
  protected:
  explicit UsersOnline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated .chat_sistOS.User users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::chat_sistOS::User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat_sistOS::User >*
      mutable_users();
  private:
  const ::chat_sistOS::User& _internal_users(int index) const;
  ::chat_sistOS::User* _internal_add_users();
  public:
  const ::chat_sistOS::User& users(int index) const;
  ::chat_sistOS::User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat_sistOS::User >&
      users() const;

  // @@protoc_insertion_point(class_scope:chat_sistOS.UsersOnline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat_sistOS::User > users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class UserOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.UserOption) */ {
 public:
  inline UserOption() : UserOption(nullptr) {}
  ~UserOption() override;
  explicit PROTOBUF_CONSTEXPR UserOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserOption(const UserOption& from);
  UserOption(UserOption&& from) noexcept
    : UserOption() {
    *this = ::std::move(from);
  }

  inline UserOption& operator=(const UserOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserOption& operator=(UserOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserOption* internal_default_instance() {
    return reinterpret_cast<const UserOption*>(
               &_UserOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(UserOption& a, UserOption& b) {
    a.Swap(&b);
  }
  inline void Swap(UserOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UserOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UserOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UserOption& from) {
    UserOption::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.UserOption";
  }
  protected:
  explicit UserOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreateUserFieldNumber = 2,
    kUserListFieldNumber = 3,
    kStatusFieldNumber = 4,
    kMessageFieldNumber = 5,
    kOpFieldNumber = 1,
  };
  // .chat_sistOS.NewUser createUser = 2;
  bool has_createuser() const;
  private:
  bool _internal_has_createuser() const;
  public:
  void clear_createuser();
  const ::chat_sistOS::NewUser& createuser() const;
  PROTOBUF_NODISCARD ::chat_sistOS::NewUser* release_createuser();
  ::chat_sistOS::NewUser* mutable_createuser();
  void set_allocated_createuser(::chat_sistOS::NewUser* createuser);
  private:
  const ::chat_sistOS::NewUser& _internal_createuser() const;
  ::chat_sistOS::NewUser* _internal_mutable_createuser();
  public:
  void unsafe_arena_set_allocated_createuser(
      ::chat_sistOS::NewUser* createuser);
  ::chat_sistOS::NewUser* unsafe_arena_release_createuser();

  // .chat_sistOS.UserList userList = 3;
  bool has_userlist() const;
  private:
  bool _internal_has_userlist() const;
  public:
  void clear_userlist();
  const ::chat_sistOS::UserList& userlist() const;
  PROTOBUF_NODISCARD ::chat_sistOS::UserList* release_userlist();
  ::chat_sistOS::UserList* mutable_userlist();
  void set_allocated_userlist(::chat_sistOS::UserList* userlist);
  private:
  const ::chat_sistOS::UserList& _internal_userlist() const;
  ::chat_sistOS::UserList* _internal_mutable_userlist();
  public:
  void unsafe_arena_set_allocated_userlist(
      ::chat_sistOS::UserList* userlist);
  ::chat_sistOS::UserList* unsafe_arena_release_userlist();

  // .chat_sistOS.Status status = 4;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::chat_sistOS::Status& status() const;
  PROTOBUF_NODISCARD ::chat_sistOS::Status* release_status();
  ::chat_sistOS::Status* mutable_status();
  void set_allocated_status(::chat_sistOS::Status* status);
  private:
  const ::chat_sistOS::Status& _internal_status() const;
  ::chat_sistOS::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::chat_sistOS::Status* status);
  ::chat_sistOS::Status* unsafe_arena_release_status();

  // .chat_sistOS.Message message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::chat_sistOS::Message& message() const;
  PROTOBUF_NODISCARD ::chat_sistOS::Message* release_message();
  ::chat_sistOS::Message* mutable_message();
  void set_allocated_message(::chat_sistOS::Message* message);
  private:
  const ::chat_sistOS::Message& _internal_message() const;
  ::chat_sistOS::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::chat_sistOS::Message* message);
  ::chat_sistOS::Message* unsafe_arena_release_message();

  // int32 op = 1;
  void clear_op();
  int32_t op() const;
  void set_op(int32_t value);
  private:
  int32_t _internal_op() const;
  void _internal_set_op(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.UserOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::chat_sistOS::NewUser* createuser_;
    ::chat_sistOS::UserList* userlist_;
    ::chat_sistOS::Status* status_;
    ::chat_sistOS::Message* message_;
    int32_t op_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class Answer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.Answer) */ {
 public:
  inline Answer() : Answer(nullptr) {}
  ~Answer() override;
  explicit PROTOBUF_CONSTEXPR Answer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Answer(const Answer& from);
  Answer(Answer&& from) noexcept
    : Answer() {
    *this = ::std::move(from);
  }

  inline Answer& operator=(const Answer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Answer& operator=(Answer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Answer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Answer* internal_default_instance() {
    return reinterpret_cast<const Answer*>(
               &_Answer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Answer& a, Answer& b) {
    a.Swap(&b);
  }
  inline void Swap(Answer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Answer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Answer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Answer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Answer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Answer& from) {
    Answer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Answer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.Answer";
  }
  protected:
  explicit Answer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseMessageFieldNumber = 3,
    kUsersOnlineFieldNumber = 4,
    kMessageFieldNumber = 5,
    kUserFieldNumber = 6,
    kStatusFieldNumber = 7,
    kOpFieldNumber = 1,
    kResponseStatusCodeFieldNumber = 2,
  };
  // string response_message = 3;
  void clear_response_message();
  const std::string& response_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_message();
  PROTOBUF_NODISCARD std::string* release_response_message();
  void set_allocated_response_message(std::string* response_message);
  private:
  const std::string& _internal_response_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_message(const std::string& value);
  std::string* _internal_mutable_response_message();
  public:

  // .chat_sistOS.UsersOnline users_online = 4;
  bool has_users_online() const;
  private:
  bool _internal_has_users_online() const;
  public:
  void clear_users_online();
  const ::chat_sistOS::UsersOnline& users_online() const;
  PROTOBUF_NODISCARD ::chat_sistOS::UsersOnline* release_users_online();
  ::chat_sistOS::UsersOnline* mutable_users_online();
  void set_allocated_users_online(::chat_sistOS::UsersOnline* users_online);
  private:
  const ::chat_sistOS::UsersOnline& _internal_users_online() const;
  ::chat_sistOS::UsersOnline* _internal_mutable_users_online();
  public:
  void unsafe_arena_set_allocated_users_online(
      ::chat_sistOS::UsersOnline* users_online);
  ::chat_sistOS::UsersOnline* unsafe_arena_release_users_online();

  // .chat_sistOS.Message message = 5;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const ::chat_sistOS::Message& message() const;
  PROTOBUF_NODISCARD ::chat_sistOS::Message* release_message();
  ::chat_sistOS::Message* mutable_message();
  void set_allocated_message(::chat_sistOS::Message* message);
  private:
  const ::chat_sistOS::Message& _internal_message() const;
  ::chat_sistOS::Message* _internal_mutable_message();
  public:
  void unsafe_arena_set_allocated_message(
      ::chat_sistOS::Message* message);
  ::chat_sistOS::Message* unsafe_arena_release_message();

  // .chat_sistOS.User user = 6;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::chat_sistOS::User& user() const;
  PROTOBUF_NODISCARD ::chat_sistOS::User* release_user();
  ::chat_sistOS::User* mutable_user();
  void set_allocated_user(::chat_sistOS::User* user);
  private:
  const ::chat_sistOS::User& _internal_user() const;
  ::chat_sistOS::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::chat_sistOS::User* user);
  ::chat_sistOS::User* unsafe_arena_release_user();

  // .chat_sistOS.Status status = 7;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::chat_sistOS::Status& status() const;
  PROTOBUF_NODISCARD ::chat_sistOS::Status* release_status();
  ::chat_sistOS::Status* mutable_status();
  void set_allocated_status(::chat_sistOS::Status* status);
  private:
  const ::chat_sistOS::Status& _internal_status() const;
  ::chat_sistOS::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::chat_sistOS::Status* status);
  ::chat_sistOS::Status* unsafe_arena_release_status();

  // int32 op = 1;
  void clear_op();
  int32_t op() const;
  void set_op(int32_t value);
  private:
  int32_t _internal_op() const;
  void _internal_set_op(int32_t value);
  public:

  // int32 response_status_code = 2;
  void clear_response_status_code();
  int32_t response_status_code() const;
  void set_response_status_code(int32_t value);
  private:
  int32_t _internal_response_status_code() const;
  void _internal_set_response_status_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.Answer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_message_;
    ::chat_sistOS::UsersOnline* users_online_;
    ::chat_sistOS::Message* message_;
    ::chat_sistOS::User* user_;
    ::chat_sistOS::Status* status_;
    int32_t op_;
    int32_t response_status_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kUserIpFieldNumber = 2,
    kUserStateFieldNumber = 3,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // string user_ip = 2;
  void clear_user_ip();
  const std::string& user_ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_ip();
  PROTOBUF_NODISCARD std::string* release_user_ip();
  void set_allocated_user_ip(std::string* user_ip);
  private:
  const std::string& _internal_user_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_ip(const std::string& value);
  std::string* _internal_mutable_user_ip();
  public:

  // int32 user_state = 3;
  void clear_user_state();
  int32_t user_state() const;
  void set_user_state(int32_t value);
  private:
  int32_t _internal_user_state() const;
  void _internal_set_user_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_ip_;
    int32_t user_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class NewUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.NewUser) */ {
 public:
  inline NewUser() : NewUser(nullptr) {}
  ~NewUser() override;
  explicit PROTOBUF_CONSTEXPR NewUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NewUser(const NewUser& from);
  NewUser(NewUser&& from) noexcept
    : NewUser() {
    *this = ::std::move(from);
  }

  inline NewUser& operator=(const NewUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline NewUser& operator=(NewUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NewUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const NewUser* internal_default_instance() {
    return reinterpret_cast<const NewUser*>(
               &_NewUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NewUser& a, NewUser& b) {
    a.Swap(&b);
  }
  inline void Swap(NewUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NewUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NewUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NewUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NewUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NewUser& from) {
    NewUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.NewUser";
  }
  protected:
  explicit NewUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsernameFieldNumber = 1,
    kIPFieldNumber = 2,
  };
  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string IP = 2;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.NewUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class Status final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.Status) */ {
 public:
  inline Status() : Status(nullptr) {}
  ~Status() override;
  explicit PROTOBUF_CONSTEXPR Status(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Status& default_instance() {
    return *internal_default_instance();
  }
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Status& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Status& from) {
    Status::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kUserStateFieldNumber = 2,
  };
  // string user_name = 1;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // int32 user_state = 2;
  void clear_user_state();
  int32_t user_state() const;
  void set_user_state(int32_t value);
  private:
  int32_t _internal_user_state() const;
  void _internal_set_user_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    int32_t user_state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:chat_sistOS.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "chat_sistOS.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageDestinationFieldNumber = 2,
    kMessageContentFieldNumber = 3,
    kMessageSenderFieldNumber = 4,
    kMessagePrivateFieldNumber = 1,
  };
  // string message_destination = 2;
  void clear_message_destination();
  const std::string& message_destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_destination();
  PROTOBUF_NODISCARD std::string* release_message_destination();
  void set_allocated_message_destination(std::string* message_destination);
  private:
  const std::string& _internal_message_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_destination(const std::string& value);
  std::string* _internal_mutable_message_destination();
  public:

  // string message_content = 3;
  void clear_message_content();
  const std::string& message_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_content();
  PROTOBUF_NODISCARD std::string* release_message_content();
  void set_allocated_message_content(std::string* message_content);
  private:
  const std::string& _internal_message_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_content(const std::string& value);
  std::string* _internal_mutable_message_content();
  public:

  // string message_sender = 4;
  void clear_message_sender();
  const std::string& message_sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_sender();
  PROTOBUF_NODISCARD std::string* release_message_sender();
  void set_allocated_message_sender(std::string* message_sender);
  private:
  const std::string& _internal_message_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_sender(const std::string& value);
  std::string* _internal_mutable_message_sender();
  public:

  // bool message_private = 1;
  void clear_message_private();
  bool message_private() const;
  void set_message_private(bool value);
  private:
  bool _internal_message_private() const;
  void _internal_set_message_private(bool value);
  public:

  // @@protoc_insertion_point(class_scope:chat_sistOS.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_sender_;
    bool message_private_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_chat_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserList

// bool list = 1;
inline void UserList::clear_list() {
  _impl_.list_ = false;
}
inline bool UserList::_internal_list() const {
  return _impl_.list_;
}
inline bool UserList::list() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserList.list)
  return _internal_list();
}
inline void UserList::_internal_set_list(bool value) {
  
  _impl_.list_ = value;
}
inline void UserList::set_list(bool value) {
  _internal_set_list(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.UserList.list)
}

// string user_name = 2;
inline void UserList::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& UserList::user_name() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserList.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UserList::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.UserList.user_name)
}
inline std::string* UserList::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.UserList.user_name)
  return _s;
}
inline const std::string& UserList::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void UserList::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* UserList::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* UserList::release_user_name() {
  // @@protoc_insertion_point(field_release:chat_sistOS.UserList.user_name)
  return _impl_.user_name_.Release();
}
inline void UserList::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.UserList.user_name)
}

// -------------------------------------------------------------------

// UsersOnline

// repeated .chat_sistOS.User users = 1;
inline int UsersOnline::_internal_users_size() const {
  return _impl_.users_.size();
}
inline int UsersOnline::users_size() const {
  return _internal_users_size();
}
inline void UsersOnline::clear_users() {
  _impl_.users_.Clear();
}
inline ::chat_sistOS::User* UsersOnline::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:chat_sistOS.UsersOnline.users)
  return _impl_.users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat_sistOS::User >*
UsersOnline::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:chat_sistOS.UsersOnline.users)
  return &_impl_.users_;
}
inline const ::chat_sistOS::User& UsersOnline::_internal_users(int index) const {
  return _impl_.users_.Get(index);
}
inline const ::chat_sistOS::User& UsersOnline::users(int index) const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UsersOnline.users)
  return _internal_users(index);
}
inline ::chat_sistOS::User* UsersOnline::_internal_add_users() {
  return _impl_.users_.Add();
}
inline ::chat_sistOS::User* UsersOnline::add_users() {
  ::chat_sistOS::User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:chat_sistOS.UsersOnline.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::chat_sistOS::User >&
UsersOnline::users() const {
  // @@protoc_insertion_point(field_list:chat_sistOS.UsersOnline.users)
  return _impl_.users_;
}

// -------------------------------------------------------------------

// UserOption

// int32 op = 1;
inline void UserOption::clear_op() {
  _impl_.op_ = 0;
}
inline int32_t UserOption::_internal_op() const {
  return _impl_.op_;
}
inline int32_t UserOption::op() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserOption.op)
  return _internal_op();
}
inline void UserOption::_internal_set_op(int32_t value) {
  
  _impl_.op_ = value;
}
inline void UserOption::set_op(int32_t value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.UserOption.op)
}

// .chat_sistOS.NewUser createUser = 2;
inline bool UserOption::_internal_has_createuser() const {
  return this != internal_default_instance() && _impl_.createuser_ != nullptr;
}
inline bool UserOption::has_createuser() const {
  return _internal_has_createuser();
}
inline void UserOption::clear_createuser() {
  if (GetArenaForAllocation() == nullptr && _impl_.createuser_ != nullptr) {
    delete _impl_.createuser_;
  }
  _impl_.createuser_ = nullptr;
}
inline const ::chat_sistOS::NewUser& UserOption::_internal_createuser() const {
  const ::chat_sistOS::NewUser* p = _impl_.createuser_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::NewUser&>(
      ::chat_sistOS::_NewUser_default_instance_);
}
inline const ::chat_sistOS::NewUser& UserOption::createuser() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserOption.createUser)
  return _internal_createuser();
}
inline void UserOption::unsafe_arena_set_allocated_createuser(
    ::chat_sistOS::NewUser* createuser) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.createuser_);
  }
  _impl_.createuser_ = createuser;
  if (createuser) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.UserOption.createUser)
}
inline ::chat_sistOS::NewUser* UserOption::release_createuser() {
  
  ::chat_sistOS::NewUser* temp = _impl_.createuser_;
  _impl_.createuser_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::NewUser* UserOption::unsafe_arena_release_createuser() {
  // @@protoc_insertion_point(field_release:chat_sistOS.UserOption.createUser)
  
  ::chat_sistOS::NewUser* temp = _impl_.createuser_;
  _impl_.createuser_ = nullptr;
  return temp;
}
inline ::chat_sistOS::NewUser* UserOption::_internal_mutable_createuser() {
  
  if (_impl_.createuser_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::NewUser>(GetArenaForAllocation());
    _impl_.createuser_ = p;
  }
  return _impl_.createuser_;
}
inline ::chat_sistOS::NewUser* UserOption::mutable_createuser() {
  ::chat_sistOS::NewUser* _msg = _internal_mutable_createuser();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.UserOption.createUser)
  return _msg;
}
inline void UserOption::set_allocated_createuser(::chat_sistOS::NewUser* createuser) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.createuser_;
  }
  if (createuser) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(createuser);
    if (message_arena != submessage_arena) {
      createuser = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, createuser, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.createuser_ = createuser;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.UserOption.createUser)
}

// .chat_sistOS.UserList userList = 3;
inline bool UserOption::_internal_has_userlist() const {
  return this != internal_default_instance() && _impl_.userlist_ != nullptr;
}
inline bool UserOption::has_userlist() const {
  return _internal_has_userlist();
}
inline void UserOption::clear_userlist() {
  if (GetArenaForAllocation() == nullptr && _impl_.userlist_ != nullptr) {
    delete _impl_.userlist_;
  }
  _impl_.userlist_ = nullptr;
}
inline const ::chat_sistOS::UserList& UserOption::_internal_userlist() const {
  const ::chat_sistOS::UserList* p = _impl_.userlist_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::UserList&>(
      ::chat_sistOS::_UserList_default_instance_);
}
inline const ::chat_sistOS::UserList& UserOption::userlist() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserOption.userList)
  return _internal_userlist();
}
inline void UserOption::unsafe_arena_set_allocated_userlist(
    ::chat_sistOS::UserList* userlist) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.userlist_);
  }
  _impl_.userlist_ = userlist;
  if (userlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.UserOption.userList)
}
inline ::chat_sistOS::UserList* UserOption::release_userlist() {
  
  ::chat_sistOS::UserList* temp = _impl_.userlist_;
  _impl_.userlist_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::UserList* UserOption::unsafe_arena_release_userlist() {
  // @@protoc_insertion_point(field_release:chat_sistOS.UserOption.userList)
  
  ::chat_sistOS::UserList* temp = _impl_.userlist_;
  _impl_.userlist_ = nullptr;
  return temp;
}
inline ::chat_sistOS::UserList* UserOption::_internal_mutable_userlist() {
  
  if (_impl_.userlist_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::UserList>(GetArenaForAllocation());
    _impl_.userlist_ = p;
  }
  return _impl_.userlist_;
}
inline ::chat_sistOS::UserList* UserOption::mutable_userlist() {
  ::chat_sistOS::UserList* _msg = _internal_mutable_userlist();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.UserOption.userList)
  return _msg;
}
inline void UserOption::set_allocated_userlist(::chat_sistOS::UserList* userlist) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.userlist_;
  }
  if (userlist) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(userlist);
    if (message_arena != submessage_arena) {
      userlist = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, userlist, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.userlist_ = userlist;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.UserOption.userList)
}

// .chat_sistOS.Status status = 4;
inline bool UserOption::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool UserOption::has_status() const {
  return _internal_has_status();
}
inline void UserOption::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::chat_sistOS::Status& UserOption::_internal_status() const {
  const ::chat_sistOS::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::Status&>(
      ::chat_sistOS::_Status_default_instance_);
}
inline const ::chat_sistOS::Status& UserOption::status() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserOption.status)
  return _internal_status();
}
inline void UserOption::unsafe_arena_set_allocated_status(
    ::chat_sistOS::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.UserOption.status)
}
inline ::chat_sistOS::Status* UserOption::release_status() {
  
  ::chat_sistOS::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::Status* UserOption::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:chat_sistOS.UserOption.status)
  
  ::chat_sistOS::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::chat_sistOS::Status* UserOption::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::chat_sistOS::Status* UserOption::mutable_status() {
  ::chat_sistOS::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.UserOption.status)
  return _msg;
}
inline void UserOption::set_allocated_status(::chat_sistOS::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.UserOption.status)
}

// .chat_sistOS.Message message = 5;
inline bool UserOption::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool UserOption::has_message() const {
  return _internal_has_message();
}
inline void UserOption::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::chat_sistOS::Message& UserOption::_internal_message() const {
  const ::chat_sistOS::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::Message&>(
      ::chat_sistOS::_Message_default_instance_);
}
inline const ::chat_sistOS::Message& UserOption::message() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.UserOption.message)
  return _internal_message();
}
inline void UserOption::unsafe_arena_set_allocated_message(
    ::chat_sistOS::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.UserOption.message)
}
inline ::chat_sistOS::Message* UserOption::release_message() {
  
  ::chat_sistOS::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::Message* UserOption::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:chat_sistOS.UserOption.message)
  
  ::chat_sistOS::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::chat_sistOS::Message* UserOption::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::chat_sistOS::Message* UserOption::mutable_message() {
  ::chat_sistOS::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.UserOption.message)
  return _msg;
}
inline void UserOption::set_allocated_message(::chat_sistOS::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.UserOption.message)
}

// -------------------------------------------------------------------

// Answer

// int32 op = 1;
inline void Answer::clear_op() {
  _impl_.op_ = 0;
}
inline int32_t Answer::_internal_op() const {
  return _impl_.op_;
}
inline int32_t Answer::op() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.op)
  return _internal_op();
}
inline void Answer::_internal_set_op(int32_t value) {
  
  _impl_.op_ = value;
}
inline void Answer::set_op(int32_t value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.Answer.op)
}

// int32 response_status_code = 2;
inline void Answer::clear_response_status_code() {
  _impl_.response_status_code_ = 0;
}
inline int32_t Answer::_internal_response_status_code() const {
  return _impl_.response_status_code_;
}
inline int32_t Answer::response_status_code() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.response_status_code)
  return _internal_response_status_code();
}
inline void Answer::_internal_set_response_status_code(int32_t value) {
  
  _impl_.response_status_code_ = value;
}
inline void Answer::set_response_status_code(int32_t value) {
  _internal_set_response_status_code(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.Answer.response_status_code)
}

// string response_message = 3;
inline void Answer::clear_response_message() {
  _impl_.response_message_.ClearToEmpty();
}
inline const std::string& Answer::response_message() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.response_message)
  return _internal_response_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Answer::set_response_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.response_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.Answer.response_message)
}
inline std::string* Answer::mutable_response_message() {
  std::string* _s = _internal_mutable_response_message();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Answer.response_message)
  return _s;
}
inline const std::string& Answer::_internal_response_message() const {
  return _impl_.response_message_.Get();
}
inline void Answer::_internal_set_response_message(const std::string& value) {
  
  _impl_.response_message_.Set(value, GetArenaForAllocation());
}
inline std::string* Answer::_internal_mutable_response_message() {
  
  return _impl_.response_message_.Mutable(GetArenaForAllocation());
}
inline std::string* Answer::release_response_message() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Answer.response_message)
  return _impl_.response_message_.Release();
}
inline void Answer::set_allocated_response_message(std::string* response_message) {
  if (response_message != nullptr) {
    
  } else {
    
  }
  _impl_.response_message_.SetAllocated(response_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.response_message_.IsDefault()) {
    _impl_.response_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Answer.response_message)
}

// .chat_sistOS.UsersOnline users_online = 4;
inline bool Answer::_internal_has_users_online() const {
  return this != internal_default_instance() && _impl_.users_online_ != nullptr;
}
inline bool Answer::has_users_online() const {
  return _internal_has_users_online();
}
inline void Answer::clear_users_online() {
  if (GetArenaForAllocation() == nullptr && _impl_.users_online_ != nullptr) {
    delete _impl_.users_online_;
  }
  _impl_.users_online_ = nullptr;
}
inline const ::chat_sistOS::UsersOnline& Answer::_internal_users_online() const {
  const ::chat_sistOS::UsersOnline* p = _impl_.users_online_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::UsersOnline&>(
      ::chat_sistOS::_UsersOnline_default_instance_);
}
inline const ::chat_sistOS::UsersOnline& Answer::users_online() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.users_online)
  return _internal_users_online();
}
inline void Answer::unsafe_arena_set_allocated_users_online(
    ::chat_sistOS::UsersOnline* users_online) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.users_online_);
  }
  _impl_.users_online_ = users_online;
  if (users_online) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.Answer.users_online)
}
inline ::chat_sistOS::UsersOnline* Answer::release_users_online() {
  
  ::chat_sistOS::UsersOnline* temp = _impl_.users_online_;
  _impl_.users_online_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::UsersOnline* Answer::unsafe_arena_release_users_online() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Answer.users_online)
  
  ::chat_sistOS::UsersOnline* temp = _impl_.users_online_;
  _impl_.users_online_ = nullptr;
  return temp;
}
inline ::chat_sistOS::UsersOnline* Answer::_internal_mutable_users_online() {
  
  if (_impl_.users_online_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::UsersOnline>(GetArenaForAllocation());
    _impl_.users_online_ = p;
  }
  return _impl_.users_online_;
}
inline ::chat_sistOS::UsersOnline* Answer::mutable_users_online() {
  ::chat_sistOS::UsersOnline* _msg = _internal_mutable_users_online();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Answer.users_online)
  return _msg;
}
inline void Answer::set_allocated_users_online(::chat_sistOS::UsersOnline* users_online) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.users_online_;
  }
  if (users_online) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(users_online);
    if (message_arena != submessage_arena) {
      users_online = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, users_online, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.users_online_ = users_online;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Answer.users_online)
}

// .chat_sistOS.Message message = 5;
inline bool Answer::_internal_has_message() const {
  return this != internal_default_instance() && _impl_.message_ != nullptr;
}
inline bool Answer::has_message() const {
  return _internal_has_message();
}
inline void Answer::clear_message() {
  if (GetArenaForAllocation() == nullptr && _impl_.message_ != nullptr) {
    delete _impl_.message_;
  }
  _impl_.message_ = nullptr;
}
inline const ::chat_sistOS::Message& Answer::_internal_message() const {
  const ::chat_sistOS::Message* p = _impl_.message_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::Message&>(
      ::chat_sistOS::_Message_default_instance_);
}
inline const ::chat_sistOS::Message& Answer::message() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.message)
  return _internal_message();
}
inline void Answer::unsafe_arena_set_allocated_message(
    ::chat_sistOS::Message* message) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.message_);
  }
  _impl_.message_ = message;
  if (message) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.Answer.message)
}
inline ::chat_sistOS::Message* Answer::release_message() {
  
  ::chat_sistOS::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::Message* Answer::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Answer.message)
  
  ::chat_sistOS::Message* temp = _impl_.message_;
  _impl_.message_ = nullptr;
  return temp;
}
inline ::chat_sistOS::Message* Answer::_internal_mutable_message() {
  
  if (_impl_.message_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::Message>(GetArenaForAllocation());
    _impl_.message_ = p;
  }
  return _impl_.message_;
}
inline ::chat_sistOS::Message* Answer::mutable_message() {
  ::chat_sistOS::Message* _msg = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Answer.message)
  return _msg;
}
inline void Answer::set_allocated_message(::chat_sistOS::Message* message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.message_;
  }
  if (message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(message);
    if (message_arena != submessage_arena) {
      message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, message, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.message_ = message;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Answer.message)
}

// .chat_sistOS.User user = 6;
inline bool Answer::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool Answer::has_user() const {
  return _internal_has_user();
}
inline void Answer::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::chat_sistOS::User& Answer::_internal_user() const {
  const ::chat_sistOS::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::User&>(
      ::chat_sistOS::_User_default_instance_);
}
inline const ::chat_sistOS::User& Answer::user() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.user)
  return _internal_user();
}
inline void Answer::unsafe_arena_set_allocated_user(
    ::chat_sistOS::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.Answer.user)
}
inline ::chat_sistOS::User* Answer::release_user() {
  
  ::chat_sistOS::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::User* Answer::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Answer.user)
  
  ::chat_sistOS::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::chat_sistOS::User* Answer::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::chat_sistOS::User* Answer::mutable_user() {
  ::chat_sistOS::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Answer.user)
  return _msg;
}
inline void Answer::set_allocated_user(::chat_sistOS::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Answer.user)
}

// .chat_sistOS.Status status = 7;
inline bool Answer::_internal_has_status() const {
  return this != internal_default_instance() && _impl_.status_ != nullptr;
}
inline bool Answer::has_status() const {
  return _internal_has_status();
}
inline void Answer::clear_status() {
  if (GetArenaForAllocation() == nullptr && _impl_.status_ != nullptr) {
    delete _impl_.status_;
  }
  _impl_.status_ = nullptr;
}
inline const ::chat_sistOS::Status& Answer::_internal_status() const {
  const ::chat_sistOS::Status* p = _impl_.status_;
  return p != nullptr ? *p : reinterpret_cast<const ::chat_sistOS::Status&>(
      ::chat_sistOS::_Status_default_instance_);
}
inline const ::chat_sistOS::Status& Answer::status() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Answer.status)
  return _internal_status();
}
inline void Answer::unsafe_arena_set_allocated_status(
    ::chat_sistOS::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.status_);
  }
  _impl_.status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:chat_sistOS.Answer.status)
}
inline ::chat_sistOS::Status* Answer::release_status() {
  
  ::chat_sistOS::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::chat_sistOS::Status* Answer::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Answer.status)
  
  ::chat_sistOS::Status* temp = _impl_.status_;
  _impl_.status_ = nullptr;
  return temp;
}
inline ::chat_sistOS::Status* Answer::_internal_mutable_status() {
  
  if (_impl_.status_ == nullptr) {
    auto* p = CreateMaybeMessage<::chat_sistOS::Status>(GetArenaForAllocation());
    _impl_.status_ = p;
  }
  return _impl_.status_;
}
inline ::chat_sistOS::Status* Answer::mutable_status() {
  ::chat_sistOS::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Answer.status)
  return _msg;
}
inline void Answer::set_allocated_status(::chat_sistOS::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.status_ = status;
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Answer.status)
}

// -------------------------------------------------------------------

// User

// string user_name = 1;
inline void User::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& User::user_name() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.User.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.User.user_name)
}
inline std::string* User::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.User.user_name)
  return _s;
}
inline const std::string& User::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void User::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_name() {
  // @@protoc_insertion_point(field_release:chat_sistOS.User.user_name)
  return _impl_.user_name_.Release();
}
inline void User::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.User.user_name)
}

// string user_ip = 2;
inline void User::clear_user_ip() {
  _impl_.user_ip_.ClearToEmpty();
}
inline const std::string& User::user_ip() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.User.user_ip)
  return _internal_user_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.User.user_ip)
}
inline std::string* User::mutable_user_ip() {
  std::string* _s = _internal_mutable_user_ip();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.User.user_ip)
  return _s;
}
inline const std::string& User::_internal_user_ip() const {
  return _impl_.user_ip_.Get();
}
inline void User::_internal_set_user_ip(const std::string& value) {
  
  _impl_.user_ip_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_ip() {
  
  return _impl_.user_ip_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_ip() {
  // @@protoc_insertion_point(field_release:chat_sistOS.User.user_ip)
  return _impl_.user_ip_.Release();
}
inline void User::set_allocated_user_ip(std::string* user_ip) {
  if (user_ip != nullptr) {
    
  } else {
    
  }
  _impl_.user_ip_.SetAllocated(user_ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_ip_.IsDefault()) {
    _impl_.user_ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.User.user_ip)
}

// int32 user_state = 3;
inline void User::clear_user_state() {
  _impl_.user_state_ = 0;
}
inline int32_t User::_internal_user_state() const {
  return _impl_.user_state_;
}
inline int32_t User::user_state() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.User.user_state)
  return _internal_user_state();
}
inline void User::_internal_set_user_state(int32_t value) {
  
  _impl_.user_state_ = value;
}
inline void User::set_user_state(int32_t value) {
  _internal_set_user_state(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.User.user_state)
}

// -------------------------------------------------------------------

// NewUser

// string username = 1;
inline void NewUser::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& NewUser::username() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.NewUser.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewUser::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.NewUser.username)
}
inline std::string* NewUser::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.NewUser.username)
  return _s;
}
inline const std::string& NewUser::_internal_username() const {
  return _impl_.username_.Get();
}
inline void NewUser::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* NewUser::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* NewUser::release_username() {
  // @@protoc_insertion_point(field_release:chat_sistOS.NewUser.username)
  return _impl_.username_.Release();
}
inline void NewUser::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.NewUser.username)
}

// string IP = 2;
inline void NewUser::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& NewUser::ip() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.NewUser.IP)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NewUser::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.NewUser.IP)
}
inline std::string* NewUser::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.NewUser.IP)
  return _s;
}
inline const std::string& NewUser::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void NewUser::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* NewUser::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* NewUser::release_ip() {
  // @@protoc_insertion_point(field_release:chat_sistOS.NewUser.IP)
  return _impl_.ip_.Release();
}
inline void NewUser::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.NewUser.IP)
}

// -------------------------------------------------------------------

// Status

// string user_name = 1;
inline void Status::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& Status::user_name() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Status.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Status::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.Status.user_name)
}
inline std::string* Status::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Status.user_name)
  return _s;
}
inline const std::string& Status::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void Status::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Status::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Status::release_user_name() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Status.user_name)
  return _impl_.user_name_.Release();
}
inline void Status::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Status.user_name)
}

// int32 user_state = 2;
inline void Status::clear_user_state() {
  _impl_.user_state_ = 0;
}
inline int32_t Status::_internal_user_state() const {
  return _impl_.user_state_;
}
inline int32_t Status::user_state() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Status.user_state)
  return _internal_user_state();
}
inline void Status::_internal_set_user_state(int32_t value) {
  
  _impl_.user_state_ = value;
}
inline void Status::set_user_state(int32_t value) {
  _internal_set_user_state(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.Status.user_state)
}

// -------------------------------------------------------------------

// Message

// bool message_private = 1;
inline void Message::clear_message_private() {
  _impl_.message_private_ = false;
}
inline bool Message::_internal_message_private() const {
  return _impl_.message_private_;
}
inline bool Message::message_private() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Message.message_private)
  return _internal_message_private();
}
inline void Message::_internal_set_message_private(bool value) {
  
  _impl_.message_private_ = value;
}
inline void Message::set_message_private(bool value) {
  _internal_set_message_private(value);
  // @@protoc_insertion_point(field_set:chat_sistOS.Message.message_private)
}

// string message_destination = 2;
inline void Message::clear_message_destination() {
  _impl_.message_destination_.ClearToEmpty();
}
inline const std::string& Message::message_destination() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Message.message_destination)
  return _internal_message_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.Message.message_destination)
}
inline std::string* Message::mutable_message_destination() {
  std::string* _s = _internal_mutable_message_destination();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Message.message_destination)
  return _s;
}
inline const std::string& Message::_internal_message_destination() const {
  return _impl_.message_destination_.Get();
}
inline void Message::_internal_set_message_destination(const std::string& value) {
  
  _impl_.message_destination_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_destination() {
  
  return _impl_.message_destination_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_destination() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Message.message_destination)
  return _impl_.message_destination_.Release();
}
inline void Message::set_allocated_message_destination(std::string* message_destination) {
  if (message_destination != nullptr) {
    
  } else {
    
  }
  _impl_.message_destination_.SetAllocated(message_destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_destination_.IsDefault()) {
    _impl_.message_destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Message.message_destination)
}

// string message_content = 3;
inline void Message::clear_message_content() {
  _impl_.message_content_.ClearToEmpty();
}
inline const std::string& Message::message_content() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Message.message_content)
  return _internal_message_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.Message.message_content)
}
inline std::string* Message::mutable_message_content() {
  std::string* _s = _internal_mutable_message_content();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Message.message_content)
  return _s;
}
inline const std::string& Message::_internal_message_content() const {
  return _impl_.message_content_.Get();
}
inline void Message::_internal_set_message_content(const std::string& value) {
  
  _impl_.message_content_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_content() {
  
  return _impl_.message_content_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_content() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Message.message_content)
  return _impl_.message_content_.Release();
}
inline void Message::set_allocated_message_content(std::string* message_content) {
  if (message_content != nullptr) {
    
  } else {
    
  }
  _impl_.message_content_.SetAllocated(message_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_content_.IsDefault()) {
    _impl_.message_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Message.message_content)
}

// string message_sender = 4;
inline void Message::clear_message_sender() {
  _impl_.message_sender_.ClearToEmpty();
}
inline const std::string& Message::message_sender() const {
  // @@protoc_insertion_point(field_get:chat_sistOS.Message.message_sender)
  return _internal_message_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_message_sender(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_sender_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:chat_sistOS.Message.message_sender)
}
inline std::string* Message::mutable_message_sender() {
  std::string* _s = _internal_mutable_message_sender();
  // @@protoc_insertion_point(field_mutable:chat_sistOS.Message.message_sender)
  return _s;
}
inline const std::string& Message::_internal_message_sender() const {
  return _impl_.message_sender_.Get();
}
inline void Message::_internal_set_message_sender(const std::string& value) {
  
  _impl_.message_sender_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_message_sender() {
  
  return _impl_.message_sender_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_message_sender() {
  // @@protoc_insertion_point(field_release:chat_sistOS.Message.message_sender)
  return _impl_.message_sender_.Release();
}
inline void Message::set_allocated_message_sender(std::string* message_sender) {
  if (message_sender != nullptr) {
    
  } else {
    
  }
  _impl_.message_sender_.SetAllocated(message_sender, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_sender_.IsDefault()) {
    _impl_.message_sender_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:chat_sistOS.Message.message_sender)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chat_sistOS

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_chat_2eproto
